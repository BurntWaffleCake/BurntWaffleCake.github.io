<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../styles/articlestylesheet.css">
    <link rel="stylesheet" href="https://fonts.google.com/specimen/Lora">
</head>

<style>
    .image-holder {
        max-width: 100%;
    }

    .image-holder img {
        max-width: 100%;
        height: auto;
        background-color: white;
    }

    .article-nav-header {
        font-size: larger;
    }
</style>

<body>
    <object id="global-nav-object" data="../../articleTemplateObjects/articleGlobalNavObject.html"></object>

    <div id="article-body">
        <object data="../../articleTemplateObjects/csArticleNavObject.html"></object>

        <div class="vertical-divider"></div>

        <article id="article-contents">
            <h1>Advanced Sort Algorithms</h1>

            <h2 id="Abstract"><u>Abstract</u></h2>
            <p>This article will talk about 3 sorting algorithms: Merge sort, Quicksort, and Heap sort. These algorithms
                are
                common sorting algorithms with varying time and space complexities and all have their own advantages and
                disadvantages. This article will be going through how these algorithms work and their efficiencies
                compared
                to other common sorting algorithms such as bubble sort.</p>

            <hr style="width: 90%;" />

            <h2 id="MergeSort"><u>Merge Sort</u></h2>
            <p>Merge sort works by separating an initial input array and then "merging" them together to a final sorted
                array output. The initial array is split into even halves (odd element counts allocate the remaining
                element
                to either the left or right array) recursively until only one element (or none in the case of odd
                elements)
                remains in each half. These halves are then combined together sorting each element accordingly until all
                halves are combined together.</p>

            <h3 id="MergeSort_0">Merging Arrays</h3>
            <p>The merge sorts entire premise revolves around the merging of subarrays to sort the larger input array.
                This
                can be accomplished by copying the subarrays from the input array, iterating over one subarray whilst
                comparing it with values from the other subarray and substituting the values in sorted order into the
                input
                array. We can assume that the initial subarrays are already sorted when the merge happens meaning that
                once
                we run out of values to compare in either of the subarrays, the rest of the other subarray is already
                sorted
                and can be assigned back into the input array without any comparisons.</p>

            <h3 id="MergeSort_1">Advantages and Disadvantages</h3>
            <p>Merge sort is generally more efficient for larger arrays but requires much more memory than sorts such as
                quicksort and bubble sort. This is a consequence from the sorting algorithms external sorting requiring
                extra
                temporary memory to store the subdivided arrays. Merge sort can also be slower when applied to shorter
                arrays. Merge sort is a stable sort meaning duplicate values maintain their relative positions in the
                resultant array.</p>

            <h3 id="MergeSort_2">Time Complexity and Space Complexity:</h3>
            <p>Time Complexity: O(nLog(n)) (worst case and best case)<br />
                Space Complexity: O(n) <br />
            </p>

            <hr style="width: 90%;" />

            <h2 id="QuickSort"><u>Quick Sort</u></h2>
            <p>Quick sort works by recursively selecting a pivot (there are multiple ways to determine the best pivot
                however we will consider it as the last element of the array in this case) and partitioning the input
                array
                into elements smaller than the pivot and elements larger than the pivot. This is continued until only
                one
                element remains in each partition leaving the array sorted. The algorithm's speed depends on
                the way the pivot is selected and bad pivots can result in slower sorting times.</p>

            <div style="text-align: center;">
                <img style="width: 35%;"
                    src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-sixth-step.png"
                    alt="failed to load :P">
            </div>

            <h3 id="QuickSort_0">Partitioning and Rearranging</h3>
            <p>
                To rearrange the input array into partitions smaller and larger than the pivot a series of comparisons
                and
                swapping must happen. (1) First, we compare values starting from the first element and test whether the
                pivot is larger than the pivot value. If the value is larger, we set a pointer on that value and move on
                to
                the next. (2) We then continue to compare each element until we reach one that is smaller than the
                pointer
                value we assigned. These two values (the pointer value and the smaller-than-pivot value) are swapped and
                our
                pointer value is assigned the next element in the list after the initial pointer value. (3) This process
                is
                then repeated through the entire array (excluding the pivot which is the last element in this case). (4)
                The
                pivot value is then swapped with the last pointer value finalizing the rearranging process. This
                algorithm
                guarantees that values smaller than the pivot appear right of the pivot values final index and values
                larger
                than the pivot appear on the left. Later recursive partitioning will include exclude the pivot used
                during
                rearranging.
            </p>

            <div style="text-align: center;">
                <p>(1)</p>
                <img style="width: 55%;"
                    src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-second-step.png"
                    alt="failed to load :P">

                <p>(2)</p>
                <img style="width: 55%;"
                    src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-third-step.png"
                    alt="failed to load :P">

                <p>(3)</p>
                <img style="width: 55%;"
                    src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-fifth-step.png"
                    alt="failed to load :P">

                <p>(4)</p>
                <img style="width: 55%;"
                    src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-sixth-step.png"
                    alt="failed to load :P">

                <p>(Recursively)</p>
                <img style="width: 55%;" src="https://www.programiz.com/sites/tutorial2program/files/quick-sort_1.png"
                    alt="failed to load :P">
            </div>

            <h3 id="QuickSort_1">Advantages and Disadvantages</h3>
            <p>Quick sort is dependent on the pivot to determine the time complexity of the algorithm. The worst case
                scenario is when the pivot is either the greatest or least value in the array. The best case scenario
                results from the pivot being near the "middle" or "center" value of the sorted array. Quick sort uses a
                substantially less amount of memory than merge sort as all partitioning is contained within the original
                array. Quick sort is an unstable algorithm meaning duplicate values do not maintain their relative
                positions
                in the resultant array.</p>

            <h3 id="QuickSort_2">Time Complexity and Space Complexity:</h3>
            <p>Time Complexity: O(n^2) (worst case)<br />
                Time Complexity: O(nLog(n)) (best case)<br />
                Space Complexity: O(Log(n)) <br />
            </p>

            <hr style="width: 90%;" />

            <h2 id="HeapSort"><u>Heap Sort</u></h2>
            <h3 id="HeapSort_0">What Is a Complete Binary Tree?</h3>
            <p>To define what a heap is we must first explore what a complete binary tree is. A complete binary tree is
                a
                data structure that organizes a dataset into a root, branches and nodes each with their respective
                parent
                and children. The root of a complete binary tree is the start of the binary tree and has no parent. A
                node
                contains a value and is connected to other nodes or the root forming a branch or path down to another
                node.
                Branches are paths that connect the root to a node that doesn't have a child node. Leafs are nodes that
                do
                not contain any children nodes. To determine which values go down which branch one can apply this rule:
                if
                the index of the specified element is i, the element with index 2i+1 will become the left child node and
                the
                element with index 2i+2 will become the right child node of the specified node. The parent of a specific
                node can also be found using the formula (i-1)/2.</p>

            <div style="text-align: center;">
                <img style="width: 35%"
                    src="https://www.programiz.com/sites/tutorial2program/files/array-vs-heap-indices.png"
                    alt="failed to load :P">
            </div>

            <h3 id="HeapSort_1">What Is a Heap?</h3>
            <p>A heap is a complete binary tree in which all nodes follow the rule that they are greater than their
                children. This is called a max heap. The heap sorting algorithm uses heaps to sort a list of values by
                heapifying partitions of an array and removing the greatest node until the algorithm has sorted the
                input
                array. To heapify an array we start with the rightmost node that is not a leaf and swap the node with
                any of
                its children (starting the comparison with the left child) if the node's value is less than the child's
                value. This swapping is continued with all other non leaf nodes from the rightmost node's index down to
                and
                including 0.</p>

            <div style="text-align: center;">
                <img style="width: 35%"
                    src="https://www.programiz.com/sites/tutorial2program/files/max-heap-min-heap.png"
                    alt="failed to load :P">
            </div>


            <h3 id="HeapSort_2">Sorting the Elements</h3>
            <p>With heapifying in mind, the heap sort operates by continually heaping an array, swaping the root node
                and
                the right-most leaf node, and removing the last
                element from the previous heap cycle (the number of elements being heaped is reduced by 1 after every
                heapify we do). This is continued until all elements are removed from the heap resulting in a sorted
                array.
            </p>

            <div style="display: flex; justify-content: center; align-items: center;">
                <div style="width: 35%; aspect-ratio: 1; overflow-y: scroll;">
                    <img style="width: 100%" src="https://www.programiz.com/sites/tutorial2program/files/heap_sort.png"
                        alt="failed to load :P">
                </div>
            </div>

            <h3 id="HeapSort_3">Advantages and Disadvantages</h3>
            <p>Heap sort is very efficient in terms of memory usage boasting the highest performance out of both the
                merge
                and quick sort. However, although the time complexity of heap sort is similar to that of quicksort and
                in
                many cases better, heap sort is often slower in real systems due to the increased complexity of the heap
                data structure. Heap sort is used over quicksort when memory usage is a problem and boasts that same
                issue
                of
                instability with quick sort.</p>

            <h3 id="HeapSort_4">Time Complexity and Space Complexity:</h3>
            <p>Time Complexity: O(nLog(n)) (worst and best case) <br />
                Space Complexity: O(1) <br />
            </p>
            <br />
            <hr />
            <br />
            <p>Graphics provided by <a href="https://www.programiz.com/" style="color: #ba9ffb;">Programiz</a></p>
        </article>

        <div class="vertical-divider"></div>

        <nav id="article-bookmarks">
            <a href="#Abstract" class="article-nav-link article-nav-header">Abstract</a>

            <a href="#MergeSort" class="article-nav-link article-nav-header">MergeSort</a>
            <a href="#MergeSort_0" class="article-nav-link">Merging Arrays</a>
            <a href="#MergeSort_1" class="article-nav-link">Advantages and Disadvantages</a>
            <a href="#MergeSort_2" class="article-nav-link">Time and Space complexity</a>

            <a href="#QuickSort" class="article-nav-link article-nav-header">QuickSort</a>
            <a href="#QuickSort_0" class="article-nav-link">Partitioning and Rearranging</a>
            <a href="#QuickSort_1" class="article-nav-link">Advantages and Disadvantages</a>
            <a href="#QuickSort_2" class="article-nav-link">Time and Space complexity</a>

            <a href="#HeapSort" class="article-nav-link article-nav-header">HeapSort</a>
            <a href="#HeapSort_0" class="article-nav-link">Complete Binary Trees</a>
            <a href="#HeapSort_1" class="article-nav-link">Heap</a>
            <a href="#HeapSort_2" class="article-nav-link">Sorting the Elements</a>
            <a href="#HeapSort_3" class="article-nav-link">Advantages and Disadvantages</a>
            <a href="#HeapSort_4" class="article-nav-link">Time and Space complexity</a>
        </nav>
    </div>
</body>

</html>